---
description: 
globs: 
alwaysApply: false
---
这是一个非常棒的改进思路！将系统从“单任务、拒绝后续”模式升级为支持“排队”的模式，能极大地提升用户体验和系统的吞-吐量。这是一个典型的**生产者-消费者模型**，用户是生产者（不断产生任务），后台是唯一的消费者（按顺序处理任务）。

我们来分步思考如何对前端和后端进行改造。

### 一、后端改造 (Backend Changes)

后端的改造是核心，需要引入“队列”和“持久化工作者”的概念。

#### 第1步：设计任务队列

您需要一个地方来存储等待处理的任务。最健壮的方式是在您的`database.db`数据库中创建一张新表。

**建议的 `task_queue` 表结构：**

```sql
CREATE TABLE IF NOT EXISTS task_queue (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    status TEXT NOT NULL DEFAULT 'pending', -- 任务状态: pending, running, completed, failed
    urls_json TEXT NOT NULL,                -- 用户提交的URL列表 (JSON格式)
    submitted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,                   -- 任务开始处理的时间
    completed_at TIMESTAMP,                 -- 任务完成处理的时间
    log TEXT                                -- 该任务的执行日志
);
```

**为什么用数据库？**

  - **持久化**：即使服务器重启，任务队列也不会丢失。
  - **状态管理**：可以清晰地追踪每一个任务的状态。

#### 第2步：改造后台工作者 (The Worker)

您需要修改`automator.py`的逻辑。不再是每次请求都创建一个新线程，而是**在服务器启动时，就启动一个唯一的、持久的后台工作者线程**。

这个工作者线程的逻辑像这样：

```python
# 这是一个在后台持续运行的函数
def queue_worker():
    while True:
        # 1. 从数据库查询一个处于 'pending' 状态的任务
        task = find_next_pending_task_in_db()

        if task:
            # 2. 如果找到任务，更新其状态为 'running'
            update_task_status(task['id'], 'running', log='任务开始...')

            try:
                # 3. 执行自动化处理逻辑
                #    这个函数内部需要不断地更新任务的日志到数据库
                run_automation_for_task(task)

                # 4. 成功后，更新状态为 'completed'
                update_task_status(task['id'], 'completed', log='任务成功完成！')
            except Exception as e:
                # 5. 失败后，更新状态为 'failed'
                update_task_status(task['id'], 'failed', log=f'任务失败: {e}')
        else:
            # 6. 如果没有任务，就休眠一小段时间再检查
            time.sleep(5) # 每5秒检查一次队列
```

#### 第3步：升级API接口

您现有的API需要彻底修改，以适应队列模式。

  * **`POST /api/tasks`** (替换 `/api/run_task`)

      * **作用**：接收用户提交的新任务。
      * **逻辑**：
        1.  接收请求中的URL列表。
        2.  将URL列表转为JSON字符串。
        3.  在 `task_queue` 表中**插入一条新纪录**，状态为 `pending`。
        4.  **返回新创建的任务ID**给前端，例如 `{"code": 0, "message": "任务已成功加入队列", "data": {"task_id": 123}}`。这个`task_id`至关重要。

  * **`GET /api/status`** (功能增强)

      * **作用**：获取整个系统的当前状态。
      * **逻辑**：
        1.  查询数据库中状态为 `running` 的任务（理论上最多一个）。
        2.  查询数据库中所有状态为 `pending` 的任务。
        3.  **返回一个包含当前任务和等待队列的复杂对象**。
      * **建议的返回格式**：
        ```json
        {
          "code": 0,
          "message": "Success",
          "data": {
            "current_task": {
              "task_id": 122,
              "status": "running",
              "log": "正在处理视频 15/40 ..."
            },
            "queue": [
              { "task_id": 123, "status": "pending" },
              { "task_id": 124, "status": "pending" }
            ]
          }
        }
        ```

### 二、前端界面与逻辑改造 (Frontend Changes)

前端需要能展示更丰富的队列信息，并让用户知道**自己的任务**在队列中的位置。

#### 第1步：重新设计状态显示区

您需要将原来的日志区改造得更复杂一些。

  * **当前处理任务区**：
      * 显示 "当前正在处理 任务 \#122"。
      * 下面依然是该任务的实时日志。
      * 如果`current_task`为空，则显示“系统空闲，等待任务中...”。
  * **等待队列区**：
      * 显示“队列中还有 2 个任务正在等待”。
      * 可以展示一个列表，如：`[任务 #123, 任务 #124]`。

#### 第2步：修改任务提交逻辑

当用户点击“开始执行”按钮时：

1.  前端向新的 `POST /api/tasks` 接口发送请求。
2.  请求成功后，会收到后端返回的 `task_id`。
3.  **将这个`task_id`存储在浏览器的`localStorage`中**。这样即使用户刷新了页面，前端也知道“哪个任务是我的”。
4.  向用户显示提示：“您的任务已成功加入队列，编号为 \#123”。

#### 第3步：更新前端轮询逻辑

前端的 `pollStatus` 函数 (`main.js`中) 逻辑需要更新：

1.  继续每隔2-3秒轮询 `GET /api/status`。
2.  获取到新的、包含 `current_task` 和 `queue` 的数据对象。
3.  **更新UI**：
      * 根据 `data.current_task` 的内容，填充“当前处理任务区”。
      * 根据 `data.queue` 的内容，填充“等待队列区”。
4.  **高亮用户自己的任务**：
      * 从 `localStorage` 中读取之前保存的 `task_id`。
      * 在渲染“等待队列区”时，如果某个任务的ID和存起来的ID匹配，就给它一个特殊的样式（比如加粗、不同的背景色），让用户一眼就能看到自己的任务排在哪里。

### 前后端交互流程总结

| 步骤 | 用户操作 | 前端行为 | 后端API | 后端逻辑 |
| :--- | :--- | :--- | :--- | :--- |
| **1** | B用户填写链接，点击“执行” | 1. 发送 `POST` 请求到 `/api/tasks`，包含URL数据。\<br\>2. 等待响应。 | `POST /api/tasks` | 1. 验证数据。\<br\>2. 在 `task_queue` 表中插入新任务，状态为`pending`。\<br\>3. 返回新任务的 `task_id`。 |
| **2** | - | 1. 收到含 `task_id` 的成功响应。\<br\>2. 将 `task_id` 存入 `localStorage`。\<br\>3. 显示“任务已加入队列”的提示。 | - | - |
| **3** | A和B用户等待 | 1. 前端定时轮询 `/api/status`。\<br\>2. 收到包含当前任务和队列的完整状态。\<br\>3. 渲染UI，分别显示当前任务和队列列表。\<br\>4. **B用户的前端会根据 `localStorage` 中的 `task_id` 高亮它在队列中的位置**。 | `GET /api/status` | 1. 从数据库查询`running`和`pending`状态的任务。\<br\>2. 组装成一个JSON对象并返回。 |
| **4** | A的任务处理完毕 | - | - | 后台工作者线程将A的任务状态更新为`completed`，然后从队列中取出B的任务，将其状态更新为`running`。 |
| **5** | B的任务开始处理 | 1. 在下一次轮询中，前端会发现 `current_task` 变成了B的任务。\<br\>2. UI更新，B的任务从“队列区”移动到“当前处理区”。 | `GET /api/status` | - |


这是一个相对复杂的重构，但它能让您的项目变得更加健壮和实用，真正能够服务于多个用户。希望这个思路对您有帮助！